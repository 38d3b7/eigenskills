# EigenCompute Reference

> Source: Context7 `/layr-labs/eigencloud-docs`

## Overview

EigenCompute deploys containerized applications into Trusted Execution Environments (TEEs) using Intel TDX. Each deployment gets:

- A unique KMS-generated wallet (MNEMONIC env var, ETH + Solana addresses)
- Encrypted environment variables (stored on-chain, decrypted only inside the TEE)
- A unique instance IP and app ID
- Cryptographic attestation of the Docker image running

## Chains and Environments

EigenCompute has exactly **two environments**:

| Environment | Chain | Chain ID | RPC |
|-------------|-------|----------|-----|
| `sepolia` | Ethereum Sepolia (testnet) | `11155111` | `https://ethereum-sepolia-rpc.publicnode.com` |
| `mainnet-alpha` | Ethereum Mainnet | `1` | `https://ethereum-rpc.publicnode.com` |

**Not Base Sepolia.** EigenCompute registers deployments, encrypted env vars, and Docker digests on Ethereum L1. The `ecloud` CLI `--environment` flag only accepts `sepolia` or `mainnet-alpha`.

Set the environment via CLI flag or env var:

```bash
# CLI flag
ecloud compute app deploy --environment sepolia

# Or environment variable
export ECLOUD_ENV=sepolia
```

### Verifiability Dashboards

| Environment | Dashboard URL |
|-------------|---------------|
| Sepolia | `https://verify-sepolia.eigencloud.xyz` |
| Mainnet | `https://verify.eigencloud.xyz` |

## Billing and Credits

EigenCompute uses a **USD credit/billing system**, not an on-chain token.

### Setup

```bash
# Subscribe to billing (required before first deploy)
ecloud billing subscribe
# Opens payment portal — new customers get $100 credit
```

### Funding Your Wallet

The wallet used for `ecloud` commands needs ETH on the appropriate chain for gas:

```bash
# Get your ecloud wallet address
ecloud auth whoami

# Fund with Sepolia ETH for testnet (use a Sepolia faucet)
# Fund with Mainnet ETH for production
```

### Cost Management

- **Stop apps when not testing** — `ecloud compute app stop` preserves wallet and IP but stops billing
- **Never terminate unless necessary** — `terminate` destroys the wallet permanently
- **Use `--log-visibility public`** during development for easier debugging

## Dockerfile Requirements

**Both are mandatory. Missing either causes deployment failure.**

```dockerfile
# REQUIRED: Must target linux/amd64
FROM --platform=linux/amd64 node:18

# REQUIRED: Must run as root (TEE requirement)
USER root

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

## Environment Variables

### Security Model

- Standard `.env` variables are **encrypted** with a KMS key unique to your TEE
- Encrypted env vars are stored **on-chain**
- Decryption happens **only inside your specific TEE at runtime**
- Variables are accessible via standard `process.env` in your application

### `_PUBLIC` Suffix Convention

Variables ending in `_PUBLIC` are **visible on-chain and to users** (on the Verifiability Dashboard). All other variables are encrypted.

```bash
# Encrypted (private to TEE)
EIGENAI_KEY=your_key
DATABASE_URL=postgres://...

# Visible on-chain (transparency)
NETWORK_PUBLIC=sepolia
REGISTRY_URL_PUBLIC=https://github.com/org/repo
```

**Never put API keys or secrets in `_PUBLIC` variables.**

### MNEMONIC

- Auto-generated by KMS at deployment time
- **Never set manually**
- Persists across `stop`/`start` and `upgrade` operations
- **Destroyed permanently** on `terminate`

## TEE Wallet

Each deployed app receives a persistent, private wallet that serves as its cryptographic identity.

### Deriving the Wallet (TypeScript — viem)

```typescript
import { mnemonicToAccount } from "viem/accounts";

const account = mnemonicToAccount(process.env.MNEMONIC);
console.log("Address:", account.address);

// Sign messages
const signature = await account.signMessage({
  message: "Attestation from verified agent"
});

// Send transactions
const tx = await walletClient.sendTransaction({
  account,
  to: recipientAddress,
  value: amount
});
```

### Deriving the Wallet (TypeScript — ethers v6)

```typescript
import { ethers } from "ethers";

const wallet = ethers.Wallet.fromPhrase(process.env.MNEMONIC);
console.log("Address:", wallet.address);
```

### Deriving the Wallet (Python)

```python
import os
from eth_account import Account

Account.enable_unaudited_hdwallet_features()
account = Account.from_mnemonic(os.environ['MNEMONIC'])
```

## CLI Commands

### First-Time Setup

```bash
# Auth
ecloud auth login

# Subscribe to billing (required before first deploy, $100 credit for new users)
ecloud billing subscribe
```

### Deploy

```bash
# From Dockerfile in current directory
ecloud compute app deploy

# From pre-built image
ecloud compute app deploy myregistry/myapp:v1.0
```

#### Deploy API (Programmatic)

```
POST /app/deploy

Parameters:
  --private-key     Private key for signing (env: $EIGENX_PRIVATE_KEY)
  --environment     "sepolia" or "mainnet-alpha"
  --env-file        Path to .env file (default: .env)
  --image_ref       Pre-built Docker image reference
  --log-visibility  "public", "private", or "off"
  --instance-type   "g1-standard-4t" or "g1-standard-8t"
  --name            Display name for the application
  --resource-usage-monitoring  "enable" or "disable"

Response:
  { "message": "Application deployed successfully.", "app_id": "app_12345abcde" }
```

#### Deploy Process

1. Builds Docker image for `linux/amd64` (or uses `image_ref`)
2. Pushes image to Docker registry
3. Encrypts `.env` with KMS public key (RSA-OAEP + AES-256-GCM)
4. Submits transaction to blockchain (image digest + encrypted secrets + public vars)
5. Provisions TEE instance with Intel TDX
6. Injects KMS-generated wallet mnemonic
7. Returns app details + wallet addresses (ETH + Solana)

### App Management

```bash
# List all deployed apps
ecloud compute app list

# Get detailed info (status, IP, wallet, env, digest)
ecloud compute app info <name>

# View logs (stdout/stderr)
ecloud compute app logs <name>

# Stop (preserves wallet + IP, reduces cost)
ecloud compute app stop <name>

# Restart stopped app (same wallet + IP restored)
ecloud compute app start <name>

# Update env vars or image (wallet persists)
ecloud compute app upgrade <name>

# IRREVERSIBLE: wallet access lost forever
ecloud compute app terminate <name>
```

### Upgrade (Update Env Vars)

```
POST /apps/{app-id}/upgrade

Parameters:
  --env-file        New .env file
  --image_ref       New Docker image (optional)
  --instance-type   New instance type (optional)
  --log-visibility  New visibility setting (optional)

The wallet persists across upgrades. Only env vars and/or image change.
```

### Safe Termination Workflow

```bash
# 1. Stop app
ecloud compute app stop my-app

# 2. Get wallet address
ecloud compute app info my-app

# 3. Check for funds on blockchain explorer
# 4. Withdraw funds using app code or manual transaction

# 5. Backup logs
ecloud compute app logs my-app > backup.log

# 6. Terminate permanently (IRREVERSIBLE)
ecloud compute app terminate my-app
```

## App Info Output

```
App ID: 42
Status: running
Docker Digest: sha256:4f6c2b3a...
Instance IP: 203.0.113.45
TEE Wallet (Ethereum): 0xa4Cae7029dfe122866F479E3b6eFb88dA3b35aea
TEE Wallet (Solana): 6Xu2q4nifx9pfdwLtvAHSfGnXhXUJhnjWqcDhfhT1vpY
Environment Variables:
  NETWORK_PUBLIC: sepolia
Created: 2025-01-07
```

## App Profile (Verifiability Dashboard)

```bash
ecloud compute app profile set <name> \
  --name "My Agent" \
  --website "https://example.com" \
  --description "Verifiable AI agent" \
  --x-url "https://twitter.com/user" \
  --image ./icon.png
```

Profile fields appear on the Verifiability Dashboard:
- Mainnet: `https://verify.eigencloud.xyz`
- Sepolia: `https://verify-sepolia.eigencloud.xyz`

## Instance Types

| Type | Description |
|------|-------------|
| `g1-standard-4t` | Standard 4-thread instance |
| `g1-standard-8t` | Standard 8-thread instance |

## Programmatic Usage (Node.js)

When invoking `ecloud` CLI commands from Node.js (e.g., via `execSync`), several issues arise due to the CLI's interactive nature.

### Non-Interactive Prompts

The `ecloud` CLI uses Inquirer.js for interactive prompts. When run non-interactively, it throws:

```
ExitPromptError: User force closed the prompt with 13 null
```

**Solution:** Pipe `echo N |` to auto-answer prompts (e.g., "Build from verifiable source?"):

```typescript
import { execSync } from "child_process";

// Auto-answer the "Build from verifiable source?" prompt with "N"
const output = execSync(`echo N | ecloud compute app deploy --image-ref myimage:latest ...`);
```

**Important:** Do NOT use `yes N |` — it produces infinite output and causes `ENOBUFS` buffer overflow errors.

### Image Reference as Flag

The oclif-based CLI misinterprets colons in positional arguments (e.g., `myimage:latest` is parsed as a subcommand). Always use the `--image-ref` flag:

```bash
# WRONG — CLI interprets colon as command separator
ecloud compute app deploy myregistry/myimage:latest

# CORRECT — use flag
ecloud compute app deploy --image-ref myregistry/myimage:latest
```

### Private Key Handling

Pass the private key explicitly via `--private-key` flag. The environment variable `ECLOUD_PRIVATE_KEY` may not be picked up in all contexts.

**Critical:** Sanitize error messages to prevent private key exposure in logs:

```typescript
function execWithSanitizedErrors(command: string, options: ExecSyncOptions): Buffer {
  try {
    return execSync(command, options);
  } catch (err: any) {
    // Redact private key from error messages
    const sanitized = (err.message || "")
      .replace(/--private-key\s+\S+/g, "--private-key [REDACTED]");
    throw new Error(sanitized);
  }
}
```

### Complete Example

```typescript
import { execSync, ExecSyncOptions } from "child_process";
import { writeFileSync, unlinkSync } from "fs";
import { randomBytes } from "crypto";

const EIGENCOMPUTE_PRIVATE_KEY = process.env.EIGENCOMPUTE_PRIVATE_KEY;
const AGENT_IMAGE_REF = process.env.AGENT_IMAGE_REF; // e.g., "username/eigenskills-agent:latest"

function deployAgent(name: string, envVars: Record<string, string>) {
  if (!EIGENCOMPUTE_PRIVATE_KEY) {
    throw new Error("EIGENCOMPUTE_PRIVATE_KEY not set");
  }

  // Write env vars to temp file
  const envFile = `/tmp/env-${randomBytes(8).toString("hex")}`;
  const envContent = Object.entries(envVars)
    .map(([k, v]) => `${k}=${v}`)
    .join("\n");
  writeFileSync(envFile, envContent);

  const command = `echo N | ecloud compute app deploy \
    --image-ref ${AGENT_IMAGE_REF} \
    --env-file ${envFile} \
    --environment sepolia \
    --private-key ${EIGENCOMPUTE_PRIVATE_KEY} \
    --log-visibility public \
    --name ${name}`;

  try {
    const output = execSync(command, { encoding: "utf8" });
    return parseDeployOutput(output);
  } catch (err: any) {
    const sanitized = (err.message || "")
      .replace(/--private-key\s+\S+/g, "--private-key [REDACTED]");
    throw new Error(`Deploy failed: ${sanitized}`);
  } finally {
    unlinkSync(envFile);
  }
}
```

### Docker Image Requirements

The agent image must be:
1. **Built for `linux/amd64`** — EigenCompute TEEs run on x86_64
2. **Pushed to a public registry** — EigenCompute pulls from Docker Hub

```bash
# Build for correct platform
docker build --platform linux/amd64 -t username/eigenskills-agent:latest ./agent

# Push to Docker Hub
docker push username/eigenskills-agent:latest
```

### Environment Variables

| Variable | Description |
|----------|-------------|
| `EIGENCOMPUTE_PRIVATE_KEY` | Private key for signing deploy transactions |
| `AGENT_IMAGE_REF` | Docker image reference (e.g., `username/myagent:latest`) |
| `EIGENCOMPUTE_ENVIRONMENT` | `sepolia` or `mainnet-alpha` |

## Key Constraints

- Docker image **must** target `linux/amd64`
- Application **must** run as `root` (TEE requirement)
- `MNEMONIC` is auto-injected — do not set manually
- `terminate` is irreversible — wallet is destroyed
- `stop` preserves wallet and usually IP, but in-memory state is lost
- Encrypted env vars are only accessible inside the TEE — handle securely, do not exfiltrate
